// 1a
void Inverter(TPilha *Pilha){
    if(!Vazia(*Pilha)){
        TPilha P1,P2;
        FPVazia(&P1);
        FPVazia(&P2);
        TProduto x;
        while(!Vazia(*Pilha)){

            Desempilhar(Pilha,&x);
            Empilhar(x,&P1);

        }
        while(!Vazia(P1)){

            Desempilhar(&P1,&x);
            Empilhar(x,&P2);

        }
        while(!Vazia(P2)){

            Desempilhar(&P2,&x);
            Empilhar(x,Pilha);

        }
        free(P1.topo);
        free(P2.topo);
    }
}


//1b
void Inverter2(TPilha *Pilha){
    if(!Vazia(*Pilha)){
        TFila F1;
        TProduto x;
        while(!Vazia(*Pilha)){
            Desempilhar(Pilha,&x);
            Enfileirar(x,&F1);
        }
        while(!Vazia(F1)){
            Desenfileirar(&F1,&x);
            Empilhar(x,Pilha);
        }
        free(F1.frente);
    }
}


//1c - UTILIZANDO UMA PILHA AUXILIAR E UMA FILA

void Inverter3(TPilha *Pilha){
    if(!Vazia(*Pilha)){
        TPilha P1;
        FPVazia(&P1);
        TFila F1;
        FFVazia(&F1);
        TProduto x;
        while(!Vazia(*Pilha)){
            Desempilhar(Pilha,&x);
            Empilhar(x,&P1);
        }
        while(!Vazia(P1)){
            Desempilhar(&P1,&x);
            Enfileirar(x,&F1);
        }
        while(!Vazia1(F1)){
            Desenfileirar(&F1,&x);
            Empilhar(x,&P1);
        }
        while(!Vazia(P1)){
            Desempilhar(&P1,&x);
            Empilhar(x,Pilha);
        }
        free(P1.topo);
        free(F1.frente);
    }
}

1-c //UTILIZANDO SOMENTE UMA PILHA AUXILIAR

void Inverte3 (TPilha *Pilha1) {
    int n = Tamanho(*Pilha1);
    TPilha Pilha2;
    FPVazia(&Pilha2);
    TProduto Aux;
    TProduto x;
    int i = 0;
    while(n != 0) {
        while(i < n-1) { // Vai desempilhar(tirar) somente n-1 um termos de Pilha1, e ira empilhar esse n-1 termos em Pilha2
            Desempilhar(Pilha1, &x);
            Empilhar(&Pilha2, x);
            i++;
        }
        Pop(Pilha1, &Aux); // O ultimo termo que sobrou em Pilha1 vai ser desempilhado de Pilha1 e Aux ira receber seu valor
        i = 0;
        while(i < n-1) { // Vai desempilhar(tirar) n-1 termos de Pilha2, sendo n-1 o tamanho da Pilha2, logo esta desempilhando todos os termos de Pilha2, 
        // e ira empilhar eles em Pilha1
            Desempilhar(&Pilha2, &x);
            Empilhar(Pilha1, x);
            i++;
        }
        Empilhar(&Pilha2, Aux); // Empilhando Aux em Pilha2
        n--;
        i = 0;
    }
    // Ao final desse laço Pilha2 ira ser igual a Pilha1
    // Com isso iremos ter que inverter
    while(!Vazia(Pilha2)) { //Desempilhando Pilha2 e Empilhando em Pilha1, logo, fazendo a Pilha1 receber o inverso da pilha
        Desempilhar(&Pilha2, &x);
        Empilhar(Pilha1, x);
    }
}


//2 - UTILIZANDO DUAS FILAS AUXILIARES

void Transfere(TPilha *Pilha1, TPilha *Pilha2){
    TFila F1, F2;
    FFVazia(&F1);
    FFVazia(&F2);
    TProduto x;
    while(!Vazia(*Pilha1)){
        Desempilhar(Pilha1,&x);
        Enfileirar(x,&F1); // Enfileirando os termos da Pilha1
    }
    while(!VaziaFila(F1)){
        Desenfileirar(&F1,&x); 
        Empilhar(x,Pilha1); // Empilhando os termos na ordem inversa de Pilha1 inicial em Pilha1
    }
    while(!Vazia(*Pilha1)){ 
        Desempilhar(Pilha1,&x); 
        Empilhar(x,Pilha2); // Empilhando os termos na ordem de Pilha1 inicial em Pilha2
        Enfileirar(x,&F2); // Enfileirando os termos inversos em F2
    }
    while(!VaziaFila(F2)){
        Desenfileirar(&F2,&x); 
        Empilhar(x,Pilha1); // Empilhando os termos na ordem de Pilha1 inicial em Pilha1
    }
    free(F1.frente); //Liberando as Filas
    free(F2.frente); 
}


//2 - UTILIZANDO SOMENTE UMA PILHA AUXILIAR

void Transfere(TPilha *Pilha1, TPilha *Pilha2){
    int n = Tamanho(*Pilha1);
    TProduto Aux;
    TProduto x;
    int i = 0;
    while(n != 0) {
        while(i < n-1) { // Vai desempilhar(tirar) somente n-1 um termos de Pilha1, e ira empilhar esse n-1 termos em Pilha2
            Desempilhar(Pilha1, &x);
            Empilhar(Pilha2, x);
            i++;
        }
        Pop(Pilha1, &Aux); // O ultimo termo que sobrou em Pilha1 vai ser desempilhado de Pilha1 e Aux ira receber seu valor
        i = 0;
        while(i < n-1) { // Vai desempilhar(tirar) n-1 termos de Pilha2, sendo n-1 o tamanho da Pilha2, logo esta desempilhando todos os termos de Pilha2, 
        // e ira empilhar eles em Pilha1
            Desempilhar(Pilha2, &x);
            Empilhar(Pilha1, x);
            i++;
        }
        Empilhar(Pilha2, Aux); // Empilhando Aux em Pilha2
        n--;
        i = 0;
    }
    // Ao final desse laço Pilha2 ira ser igual a Pilha1
}



//3

int ExpressaoAritmetica(char *str){
    TPilha P1;
    FPVazia(&P1);
    TCharacter c;
    int i = 0;
    while(*(str + i) != '\0'){
        if(*(str + i) == '{' || *(str + i) == '[' || *(str + i) == '(')
            Empilha(&P1, *(str + i));
        
        if(*(str + i) == '}') {
            if(P1.topo == '{')
                Desempilha(c, &P1);
        }
        
        if(*(str + i) == ']') {
            if(P1.topo == '[')
                Desempilha(c, &P1);
        }
        
        if(*(str + i) == ')') {
            if(P1.topo == '(')
                Desempilha(c, &P1);
        }
        i++;
    }
    
    if(Vazia(P1))
        return 1;
    else
        return 0;
 }
